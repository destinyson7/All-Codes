#include "testlib.h"

#include <iostream>
#include <string>
#include <vector>
#include <time.h>
using namespace std;

/* This checker is for the debug the code problem. It takes as input the hack
case a and b and checks if the values x and y generated by the buggy solution
are invalid.*/
typedef long long ll;

ll calcBeauty(const string& s) {
    ll sum = 0;

    for (int i = 1; i < s.size();) {
        if (s[i] == '0' && s[i - 1] == '1') {
            int j = i;

            while (j < s.size() - 1 && s[j + 1] == '0') {
                j++;
            }

            if (j + 1 < s.size()) {
                ll valleySize = j - i + 1;

                sum += valleySize * valleySize;
            }
            i = j + 1;
        } else
            i++;
    }

    return sum;
}

ll correctSolution(const string& s) {
    ll len = (ll)s.size();

    vector<ll> ones;

    for (ll i = 0; i < len; i++) {
        if (s[i] == '1') {
            ones.push_back(i);
        }
    }

    ll n = ones.size(), idx = -1, ma = 0;

    for (ll i = 0; i < n - 2; i++) {
        ll first = ones[i], middle = ones[i + 1], last = ones[i + 2];

        ll add = (last - first - 1);
        add *= add;

        ll gap1 = (middle - first - 1), gap2 = (last - middle - 1),
           sub = gap1 * gap1 + gap2 * gap2, diff = add - sub;

        if (diff > ma) {
            ma = diff;
            idx = middle;
        }
    }

    return idx;
}

long double gettimer(const struct timespec& ts) {
    return ts.tv_sec + ts.tv_nsec / 1e9;
}

const int MAXN = 1e6 + 5;
ll buggySolution(char s[MAXN]) {
    vector<ll> ones;

    // time
    // TLE for strlen

    struct timespec start, current;
    clock_gettime(CLOCK_MONOTONIC, &start);
    long double st = gettimer(start), ct;

    for (ll i = 0; i < strlen(s); i++) {
        if (s[i] == '1') {
            ones.push_back(i);
        }

        clock_gettime(CLOCK_MONOTONIC, &current);
        ct = gettimer(current);

        if (ct - st >= 1) {
            return -2;
        }
    }

    ll n = ones.size(), idx = -1, ma = 0;

    for (ll i = 0; i < n - 2; i++) {
        ll first = ones[i], middle = ones[i + 1], last = ones[i + 2];

        ll add = (last - first - 1);
        add *= add;

        ll gap1 = (middle - first - 1), gap2 = (last - middle - 1),
           sub = gap1 * gap1 + gap2 * gap2, diff = add - sub;

        if (diff > ma) {
            ma = diff;
            idx = middle;
        }
    }

    return idx;
}

int main(int argc, char* argv[]) {
    // This command initializes checker environment.
    registerTestlibCmd(argc, argv);
    // Now there are three global variables specifying testlib streams:
    // inf - stream with the testdata.
    // ouf - stream with the contestant output.
    // ans - stream with the jury answer.
    // All those streams provide the similar interface for reading data.

    int type = inf.readInt(1, 2, "type");
    int n;
    string inp, jax, pax;
    ll judgeIdx, participantIdx;

    if (type == 1) {
        n = ouf.readInt(1, 1e6, "n");
        ouf.readLine();
        inp = ouf.readLine("[01]{" + to_string(n) + "}");
        jax = inp;

        char s[n];
        for (ll i = 0; i < n; i++) {
            s[i] = inp[i];
        }

        participantIdx = buggySolution(s);

        if (participantIdx == -2) {
            quitf(_ok, "The hack case causes TLE");
            return 0;
        }

        judgeIdx = correctSolution(jax);
    } else {
        n = inf.readInt();
        inf.readLine();
        inp = inf.readLine();

        jax = inp;
        judgeIdx = ans.readLong(-1ll, n - 1, "idx");

        participantIdx = ouf.readLong(-1ll, n - 1, "idx");
    }

    if (participantIdx != -1) {
        if (inp[participantIdx] != '1') {
            if (type == 1)
                quitf(_ok,
                      "Buggy solution outputted index which is not a one.");
            else
                quitf(_wa, "Outputted index which is not a one.");
        }
        inp[participantIdx] = '0';
    }

    if (judgeIdx != -1) {
        if (jax[judgeIdx] != '1') {
            quitf(_fail, "Judge's index if not a one.");
        }
        jax[judgeIdx] = '0';
    }

    ll pb = calcBeauty(inp), jb = calcBeauty(jax);

    if (pb == jb) {
        if (type == 1)
            quitf(_wa, "The buggy solution isn't hacked.");
        else
            quitf(_ok, "Correct answer.");
    } else if (jb > pb) {
        if (type == 1)
            quitf(_ok, "Buggy solution produced poor score, hacked!");
        else
            quitf(_wa, "Participant solution produced poor score");
    } else {
        quitf(_fail,
              "Participant solution has a better answer, pb = %lld, jb = %lld.",
              pb, jb);
    }
}